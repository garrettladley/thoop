// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: recoveries.sql

package sqlc

import (
	"context"
	"strings"
	"time"
)

const deleteRecovery = `-- name: DeleteRecovery :exec
DELETE FROM recoveries WHERE cycle_id = ?
`

func (q *Queries) DeleteRecovery(ctx context.Context, cycleID int64) error {
	_, err := q.db.ExecContext(ctx, deleteRecovery, cycleID)
	return err
}

const getRecoveriesByCycleIDs = `-- name: GetRecoveriesByCycleIDs :many
SELECT cycle_id, sleep_id, user_id, created_at, updated_at, score_state, score_json, fetched_at FROM recoveries WHERE cycle_id IN (/*SLICE:cycle_ids*/?)
`

func (q *Queries) GetRecoveriesByCycleIDs(ctx context.Context, cycleIds []int64) ([]Recovery, error) {
	query := getRecoveriesByCycleIDs
	var queryParams []interface{}
	if len(cycleIds) > 0 {
		for _, v := range cycleIds {
			queryParams = append(queryParams, v)
		}
		query = strings.Replace(query, "/*SLICE:cycle_ids*/?", strings.Repeat(",?", len(cycleIds))[1:], 1)
	} else {
		query = strings.Replace(query, "/*SLICE:cycle_ids*/?", "NULL", 1)
	}
	rows, err := q.db.QueryContext(ctx, query, queryParams...)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Recovery{}
	for rows.Next() {
		var i Recovery
		if err := rows.Scan(
			&i.CycleID,
			&i.SleepID,
			&i.UserID,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.ScoreState,
			&i.ScoreJson,
			&i.FetchedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getRecovery = `-- name: GetRecovery :one
SELECT cycle_id, sleep_id, user_id, created_at, updated_at, score_state, score_json, fetched_at FROM recoveries WHERE cycle_id = ?
`

func (q *Queries) GetRecovery(ctx context.Context, cycleID int64) (Recovery, error) {
	row := q.db.QueryRowContext(ctx, getRecovery, cycleID)
	var i Recovery
	err := row.Scan(
		&i.CycleID,
		&i.SleepID,
		&i.UserID,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.ScoreState,
		&i.ScoreJson,
		&i.FetchedAt,
	)
	return i, err
}

const upsertRecovery = `-- name: UpsertRecovery :exec
INSERT INTO recoveries (cycle_id, sleep_id, user_id, created_at, updated_at, score_state, score_json, fetched_at)
VALUES (?, ?, ?, ?, ?, ?, ?, CURRENT_TIMESTAMP)
ON CONFLICT(cycle_id) DO UPDATE SET
    sleep_id = excluded.sleep_id,
    user_id = excluded.user_id,
    created_at = excluded.created_at,
    updated_at = excluded.updated_at,
    score_state = excluded.score_state,
    score_json = excluded.score_json,
    fetched_at = CURRENT_TIMESTAMP
`

type UpsertRecoveryParams struct {
	CycleID    int64     `json:"cycle_id"`
	SleepID    string    `json:"sleep_id"`
	UserID     int64     `json:"user_id"`
	CreatedAt  time.Time `json:"created_at"`
	UpdatedAt  time.Time `json:"updated_at"`
	ScoreState string    `json:"score_state"`
	ScoreJson  *string   `json:"score_json"`
}

func (q *Queries) UpsertRecovery(ctx context.Context, arg UpsertRecoveryParams) error {
	_, err := q.db.ExecContext(ctx, upsertRecovery,
		arg.CycleID,
		arg.SleepID,
		arg.UserID,
		arg.CreatedAt,
		arg.UpdatedAt,
		arg.ScoreState,
		arg.ScoreJson,
	)
	return err
}
