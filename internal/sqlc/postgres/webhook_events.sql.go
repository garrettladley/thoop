// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: webhook_events.sql

package pgc

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const acknowledgeWebhookEventsByTraceIDs = `-- name: AcknowledgeWebhookEventsByTraceIDs :exec
UPDATE webhook_events
SET acknowledged_at = now()
WHERE whoop_user_id = $1
  AND trace_id = ANY($2::text[])
  AND acknowledged_at IS NULL
`

type AcknowledgeWebhookEventsByTraceIDsParams struct {
	WhoopUserID int64    `json:"whoop_user_id"`
	TraceIds    []string `json:"trace_ids"`
}

func (q *Queries) AcknowledgeWebhookEventsByTraceIDs(ctx context.Context, arg AcknowledgeWebhookEventsByTraceIDsParams) error {
	_, err := q.db.Exec(ctx, acknowledgeWebhookEventsByTraceIDs, arg.WhoopUserID, arg.TraceIds)
	return err
}

const getUnackedWebhookEvents = `-- name: GetUnackedWebhookEvents :many
SELECT id, trace_id, whoop_user_id, timestamp, entity_id, entity_type, action
FROM webhook_events
WHERE whoop_user_id = $1
  AND acknowledged_at IS NULL
  AND id > $2
ORDER BY id
LIMIT $3
`

type GetUnackedWebhookEventsParams struct {
	WhoopUserID int64  `json:"whoop_user_id"`
	Cursor      *int64 `json:"cursor"`
	MaxResults  int32  `json:"max_results"`
}

type GetUnackedWebhookEventsRow struct {
	ID          *int64             `json:"id"`
	TraceID     string             `json:"trace_id"`
	WhoopUserID int64              `json:"whoop_user_id"`
	Timestamp   pgtype.Timestamptz `json:"timestamp"`
	EntityID    string             `json:"entity_id"`
	EntityType  string             `json:"entity_type"`
	Action      string             `json:"action"`
}

func (q *Queries) GetUnackedWebhookEvents(ctx context.Context, arg GetUnackedWebhookEventsParams) ([]GetUnackedWebhookEventsRow, error) {
	rows, err := q.db.Query(ctx, getUnackedWebhookEvents, arg.WhoopUserID, arg.Cursor, arg.MaxResults)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetUnackedWebhookEventsRow{}
	for rows.Next() {
		var i GetUnackedWebhookEventsRow
		if err := rows.Scan(
			&i.ID,
			&i.TraceID,
			&i.WhoopUserID,
			&i.Timestamp,
			&i.EntityID,
			&i.EntityType,
			&i.Action,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const insertWebhookEvent = `-- name: InsertWebhookEvent :one
INSERT INTO webhook_events (trace_id, whoop_user_id, timestamp, entity_id, entity_type, action)
VALUES ($1, $2, $3, $4, $5, $6)
ON CONFLICT (trace_id) DO NOTHING
RETURNING id
`

type InsertWebhookEventParams struct {
	TraceID     string             `json:"trace_id"`
	WhoopUserID int64              `json:"whoop_user_id"`
	Timestamp   pgtype.Timestamptz `json:"timestamp"`
	EntityID    string             `json:"entity_id"`
	EntityType  string             `json:"entity_type"`
	Action      string             `json:"action"`
}

func (q *Queries) InsertWebhookEvent(ctx context.Context, arg InsertWebhookEventParams) (*int64, error) {
	row := q.db.QueryRow(ctx, insertWebhookEvent,
		arg.TraceID,
		arg.WhoopUserID,
		arg.Timestamp,
		arg.EntityID,
		arg.EntityType,
		arg.Action,
	)
	var id *int64
	err := row.Scan(&id)
	return id, err
}
