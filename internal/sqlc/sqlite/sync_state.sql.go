// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: sync_state.sql

package sqlitec

import (
	"context"
	"time"
)

const getLastNotificationPoll = `-- name: GetLastNotificationPoll :one
SELECT last_notification_poll FROM sync_state WHERE id = 1
`

func (q *Queries) GetLastNotificationPoll(ctx context.Context) (*time.Time, error) {
	row := q.db.QueryRowContext(ctx, getLastNotificationPoll)
	var last_notification_poll *time.Time
	err := row.Scan(&last_notification_poll)
	return last_notification_poll, err
}

const getSyncState = `-- name: GetSyncState :one
SELECT id, backfill_complete, backfill_watermark, last_full_sync, created_at, updated_at, last_notification_poll FROM sync_state WHERE id = 1
`

func (q *Queries) GetSyncState(ctx context.Context) (SyncState, error) {
	row := q.db.QueryRowContext(ctx, getSyncState)
	var i SyncState
	err := row.Scan(
		&i.ID,
		&i.BackfillComplete,
		&i.BackfillWatermark,
		&i.LastFullSync,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.LastNotificationPoll,
	)
	return i, err
}

const markBackfillComplete = `-- name: MarkBackfillComplete :exec
UPDATE sync_state SET backfill_complete = 1, updated_at = CURRENT_TIMESTAMP WHERE id = 1
`

func (q *Queries) MarkBackfillComplete(ctx context.Context) error {
	_, err := q.db.ExecContext(ctx, markBackfillComplete)
	return err
}

const updateBackfillWatermark = `-- name: UpdateBackfillWatermark :exec
UPDATE sync_state SET backfill_watermark = ?, updated_at = CURRENT_TIMESTAMP WHERE id = 1
`

func (q *Queries) UpdateBackfillWatermark(ctx context.Context, backfillWatermark *time.Time) error {
	_, err := q.db.ExecContext(ctx, updateBackfillWatermark, backfillWatermark)
	return err
}

const updateLastFullSync = `-- name: UpdateLastFullSync :exec
UPDATE sync_state SET last_full_sync = ?, updated_at = CURRENT_TIMESTAMP WHERE id = 1
`

func (q *Queries) UpdateLastFullSync(ctx context.Context, lastFullSync *time.Time) error {
	_, err := q.db.ExecContext(ctx, updateLastFullSync, lastFullSync)
	return err
}

const updateLastNotificationPoll = `-- name: UpdateLastNotificationPoll :exec
UPDATE sync_state SET last_notification_poll = ?, updated_at = CURRENT_TIMESTAMP WHERE id = 1
`

func (q *Queries) UpdateLastNotificationPoll(ctx context.Context, lastNotificationPoll *time.Time) error {
	_, err := q.db.ExecContext(ctx, updateLastNotificationPoll, lastNotificationPoll)
	return err
}

const upsertSyncState = `-- name: UpsertSyncState :exec
INSERT INTO sync_state (id, backfill_complete, backfill_watermark, last_full_sync, updated_at)
VALUES (1, ?, ?, ?, CURRENT_TIMESTAMP)
ON CONFLICT(id) DO UPDATE SET
    backfill_complete = excluded.backfill_complete,
    backfill_watermark = excluded.backfill_watermark,
    last_full_sync = excluded.last_full_sync,
    updated_at = CURRENT_TIMESTAMP
`

type UpsertSyncStateParams struct {
	BackfillComplete  int64      `json:"backfill_complete"`
	BackfillWatermark *time.Time `json:"backfill_watermark"`
	LastFullSync      *time.Time `json:"last_full_sync"`
}

func (q *Queries) UpsertSyncState(ctx context.Context, arg UpsertSyncStateParams) error {
	_, err := q.db.ExecContext(ctx, upsertSyncState, arg.BackfillComplete, arg.BackfillWatermark, arg.LastFullSync)
	return err
}
