// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: cycles.sql

package sqlitec

import (
	"context"
	"time"
)

const deleteCycle = `-- name: DeleteCycle :exec
DELETE FROM cycles WHERE id = ?
`

func (q *Queries) DeleteCycle(ctx context.Context, id int64) error {
	_, err := q.db.ExecContext(ctx, deleteCycle, id)
	return err
}

const getCycle = `-- name: GetCycle :one
SELECT id, user_id, created_at, updated_at, start, "end", timezone_offset, score_state, score_json, fetched_at FROM cycles WHERE id = ?
`

func (q *Queries) GetCycle(ctx context.Context, id int64) (Cycle, error) {
	row := q.db.QueryRowContext(ctx, getCycle, id)
	var i Cycle
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.Start,
		&i.End,
		&i.TimezoneOffset,
		&i.ScoreState,
		&i.ScoreJson,
		&i.FetchedAt,
	)
	return i, err
}

const getCyclesByDateRange = `-- name: GetCyclesByDateRange :many
SELECT id, user_id, created_at, updated_at, start, "end", timezone_offset, score_state, score_json, fetched_at FROM cycles
WHERE start >= ?1 AND start <= ?2
ORDER BY start DESC
LIMIT ?3
`

type GetCyclesByDateRangeParams struct {
	RangeStart time.Time `json:"range_start"`
	RangeEnd   time.Time `json:"range_end"`
	Limit      int64     `json:"limit"`
}

func (q *Queries) GetCyclesByDateRange(ctx context.Context, arg GetCyclesByDateRangeParams) ([]Cycle, error) {
	rows, err := q.db.QueryContext(ctx, getCyclesByDateRange, arg.RangeStart, arg.RangeEnd, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Cycle{}
	for rows.Next() {
		var i Cycle
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.Start,
			&i.End,
			&i.TimezoneOffset,
			&i.ScoreState,
			&i.ScoreJson,
			&i.FetchedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getCyclesByDateRangeCursor = `-- name: GetCyclesByDateRangeCursor :many
SELECT id, user_id, created_at, updated_at, start, "end", timezone_offset, score_state, score_json, fetched_at FROM cycles
WHERE start >= ?1 AND start <= ?2 AND start < ?3
ORDER BY start DESC
LIMIT ?4
`

type GetCyclesByDateRangeCursorParams struct {
	RangeStart time.Time `json:"range_start"`
	RangeEnd   time.Time `json:"range_end"`
	Cursor     time.Time `json:"cursor"`
	Limit      int64     `json:"limit"`
}

func (q *Queries) GetCyclesByDateRangeCursor(ctx context.Context, arg GetCyclesByDateRangeCursorParams) ([]Cycle, error) {
	rows, err := q.db.QueryContext(ctx, getCyclesByDateRangeCursor,
		arg.RangeStart,
		arg.RangeEnd,
		arg.Cursor,
		arg.Limit,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Cycle{}
	for rows.Next() {
		var i Cycle
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.Start,
			&i.End,
			&i.TimezoneOffset,
			&i.ScoreState,
			&i.ScoreJson,
			&i.FetchedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getLatestCycles = `-- name: GetLatestCycles :many
SELECT id, user_id, created_at, updated_at, start, "end", timezone_offset, score_state, score_json, fetched_at FROM cycles ORDER BY start DESC LIMIT ?
`

func (q *Queries) GetLatestCycles(ctx context.Context, limit int64) ([]Cycle, error) {
	rows, err := q.db.QueryContext(ctx, getLatestCycles, limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Cycle{}
	for rows.Next() {
		var i Cycle
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.Start,
			&i.End,
			&i.TimezoneOffset,
			&i.ScoreState,
			&i.ScoreJson,
			&i.FetchedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getPendingCycles = `-- name: GetPendingCycles :many
SELECT id, user_id, created_at, updated_at, start, "end", timezone_offset, score_state, score_json, fetched_at FROM cycles WHERE score_state = 'PENDING_SCORE' ORDER BY start DESC
`

func (q *Queries) GetPendingCycles(ctx context.Context) ([]Cycle, error) {
	rows, err := q.db.QueryContext(ctx, getPendingCycles)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Cycle{}
	for rows.Next() {
		var i Cycle
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.Start,
			&i.End,
			&i.TimezoneOffset,
			&i.ScoreState,
			&i.ScoreJson,
			&i.FetchedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const upsertCycle = `-- name: UpsertCycle :exec
INSERT INTO cycles (id, user_id, created_at, updated_at, start, end, timezone_offset, score_state, score_json, fetched_at)
VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, CURRENT_TIMESTAMP)
ON CONFLICT(id) DO UPDATE SET
    user_id = excluded.user_id,
    created_at = excluded.created_at,
    updated_at = excluded.updated_at,
    start = excluded.start,
    end = excluded.end,
    timezone_offset = excluded.timezone_offset,
    score_state = excluded.score_state,
    score_json = excluded.score_json,
    fetched_at = CURRENT_TIMESTAMP
`

type UpsertCycleParams struct {
	ID             int64      `json:"id"`
	UserID         int64      `json:"user_id"`
	CreatedAt      time.Time  `json:"created_at"`
	UpdatedAt      time.Time  `json:"updated_at"`
	Start          time.Time  `json:"start"`
	End            *time.Time `json:"end"`
	TimezoneOffset string     `json:"timezone_offset"`
	ScoreState     string     `json:"score_state"`
	ScoreJson      *string    `json:"score_json"`
}

func (q *Queries) UpsertCycle(ctx context.Context, arg UpsertCycleParams) error {
	_, err := q.db.ExecContext(ctx, upsertCycle,
		arg.ID,
		arg.UserID,
		arg.CreatedAt,
		arg.UpdatedAt,
		arg.Start,
		arg.End,
		arg.TimezoneOffset,
		arg.ScoreState,
		arg.ScoreJson,
	)
	return err
}
