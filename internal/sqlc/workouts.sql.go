// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: workouts.sql

package sqlc

import (
	"context"
	"time"
)

const deleteWorkout = `-- name: DeleteWorkout :exec
DELETE FROM workouts WHERE id = ?
`

func (q *Queries) DeleteWorkout(ctx context.Context, id string) error {
	_, err := q.db.ExecContext(ctx, deleteWorkout, id)
	return err
}

const getWorkout = `-- name: GetWorkout :one
SELECT id, v1_id, user_id, created_at, updated_at, start, "end", timezone_offset, sport_name, score_state, score_json, fetched_at FROM workouts WHERE id = ?
`

func (q *Queries) GetWorkout(ctx context.Context, id string) (Workout, error) {
	row := q.db.QueryRowContext(ctx, getWorkout, id)
	var i Workout
	err := row.Scan(
		&i.ID,
		&i.V1ID,
		&i.UserID,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.Start,
		&i.End,
		&i.TimezoneOffset,
		&i.SportName,
		&i.ScoreState,
		&i.ScoreJson,
		&i.FetchedAt,
	)
	return i, err
}

const getWorkoutsByCycleID = `-- name: GetWorkoutsByCycleID :many
SELECT id, v1_id, user_id, created_at, updated_at, start, "end", timezone_offset, sport_name, score_state, score_json, fetched_at FROM workouts
WHERE workouts.start >= (SELECT cycles.start FROM cycles WHERE cycles.id = ?1)
  AND workouts.start <= COALESCE((SELECT cycles.end FROM cycles WHERE cycles.id = ?1), CURRENT_TIMESTAMP)
ORDER BY workouts.start DESC
`

func (q *Queries) GetWorkoutsByCycleID(ctx context.Context, cycleID int64) ([]Workout, error) {
	rows, err := q.db.QueryContext(ctx, getWorkoutsByCycleID, cycleID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Workout{}
	for rows.Next() {
		var i Workout
		if err := rows.Scan(
			&i.ID,
			&i.V1ID,
			&i.UserID,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.Start,
			&i.End,
			&i.TimezoneOffset,
			&i.SportName,
			&i.ScoreState,
			&i.ScoreJson,
			&i.FetchedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getWorkoutsByDateRange = `-- name: GetWorkoutsByDateRange :many
SELECT id, v1_id, user_id, created_at, updated_at, start, "end", timezone_offset, sport_name, score_state, score_json, fetched_at FROM workouts
WHERE start >= ?1 AND start <= ?2
ORDER BY start DESC
LIMIT ?3
`

type GetWorkoutsByDateRangeParams struct {
	RangeStart time.Time `json:"range_start"`
	RangeEnd   time.Time `json:"range_end"`
	Limit      int64     `json:"limit"`
}

func (q *Queries) GetWorkoutsByDateRange(ctx context.Context, arg GetWorkoutsByDateRangeParams) ([]Workout, error) {
	rows, err := q.db.QueryContext(ctx, getWorkoutsByDateRange, arg.RangeStart, arg.RangeEnd, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Workout{}
	for rows.Next() {
		var i Workout
		if err := rows.Scan(
			&i.ID,
			&i.V1ID,
			&i.UserID,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.Start,
			&i.End,
			&i.TimezoneOffset,
			&i.SportName,
			&i.ScoreState,
			&i.ScoreJson,
			&i.FetchedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getWorkoutsByDateRangeCursor = `-- name: GetWorkoutsByDateRangeCursor :many
SELECT id, v1_id, user_id, created_at, updated_at, start, "end", timezone_offset, sport_name, score_state, score_json, fetched_at FROM workouts
WHERE start >= ?1 AND start <= ?2 AND start < ?3
ORDER BY start DESC
LIMIT ?4
`

type GetWorkoutsByDateRangeCursorParams struct {
	RangeStart time.Time `json:"range_start"`
	RangeEnd   time.Time `json:"range_end"`
	Cursor     time.Time `json:"cursor"`
	Limit      int64     `json:"limit"`
}

func (q *Queries) GetWorkoutsByDateRangeCursor(ctx context.Context, arg GetWorkoutsByDateRangeCursorParams) ([]Workout, error) {
	rows, err := q.db.QueryContext(ctx, getWorkoutsByDateRangeCursor,
		arg.RangeStart,
		arg.RangeEnd,
		arg.Cursor,
		arg.Limit,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Workout{}
	for rows.Next() {
		var i Workout
		if err := rows.Scan(
			&i.ID,
			&i.V1ID,
			&i.UserID,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.Start,
			&i.End,
			&i.TimezoneOffset,
			&i.SportName,
			&i.ScoreState,
			&i.ScoreJson,
			&i.FetchedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const upsertWorkout = `-- name: UpsertWorkout :exec
INSERT INTO workouts (id, v1_id, user_id, created_at, updated_at, start, end, timezone_offset, sport_name, score_state, score_json, fetched_at)
VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, CURRENT_TIMESTAMP)
ON CONFLICT(id) DO UPDATE SET
    v1_id = excluded.v1_id,
    user_id = excluded.user_id,
    created_at = excluded.created_at,
    updated_at = excluded.updated_at,
    start = excluded.start,
    end = excluded.end,
    timezone_offset = excluded.timezone_offset,
    sport_name = excluded.sport_name,
    score_state = excluded.score_state,
    score_json = excluded.score_json,
    fetched_at = CURRENT_TIMESTAMP
`

type UpsertWorkoutParams struct {
	ID             string    `json:"id"`
	V1ID           *int64    `json:"v1_id"`
	UserID         int64     `json:"user_id"`
	CreatedAt      time.Time `json:"created_at"`
	UpdatedAt      time.Time `json:"updated_at"`
	Start          time.Time `json:"start"`
	End            time.Time `json:"end"`
	TimezoneOffset string    `json:"timezone_offset"`
	SportName      string    `json:"sport_name"`
	ScoreState     string    `json:"score_state"`
	ScoreJson      *string   `json:"score_json"`
}

func (q *Queries) UpsertWorkout(ctx context.Context, arg UpsertWorkoutParams) error {
	_, err := q.db.ExecContext(ctx, upsertWorkout,
		arg.ID,
		arg.V1ID,
		arg.UserID,
		arg.CreatedAt,
		arg.UpdatedAt,
		arg.Start,
		arg.End,
		arg.TimezoneOffset,
		arg.SportName,
		arg.ScoreState,
		arg.ScoreJson,
	)
	return err
}
