// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: sleeps.sql

package sqlc

import (
	"context"
	"time"
)

const deleteSleep = `-- name: DeleteSleep :exec
DELETE FROM sleeps WHERE id = ?
`

func (q *Queries) DeleteSleep(ctx context.Context, id string) error {
	_, err := q.db.ExecContext(ctx, deleteSleep, id)
	return err
}

const getNapsByCycleID = `-- name: GetNapsByCycleID :many
SELECT id, cycle_id, v1_id, user_id, created_at, updated_at, start, "end", timezone_offset, nap, score_state, score_json, fetched_at FROM sleeps WHERE cycle_id = ? AND nap = 1 ORDER BY start DESC
`

func (q *Queries) GetNapsByCycleID(ctx context.Context, cycleID int64) ([]Sleep, error) {
	rows, err := q.db.QueryContext(ctx, getNapsByCycleID, cycleID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Sleep{}
	for rows.Next() {
		var i Sleep
		if err := rows.Scan(
			&i.ID,
			&i.CycleID,
			&i.V1ID,
			&i.UserID,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.Start,
			&i.End,
			&i.TimezoneOffset,
			&i.Nap,
			&i.ScoreState,
			&i.ScoreJson,
			&i.FetchedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getSleep = `-- name: GetSleep :one
SELECT id, cycle_id, v1_id, user_id, created_at, updated_at, start, "end", timezone_offset, nap, score_state, score_json, fetched_at FROM sleeps WHERE id = ?
`

func (q *Queries) GetSleep(ctx context.Context, id string) (Sleep, error) {
	row := q.db.QueryRowContext(ctx, getSleep, id)
	var i Sleep
	err := row.Scan(
		&i.ID,
		&i.CycleID,
		&i.V1ID,
		&i.UserID,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.Start,
		&i.End,
		&i.TimezoneOffset,
		&i.Nap,
		&i.ScoreState,
		&i.ScoreJson,
		&i.FetchedAt,
	)
	return i, err
}

const getSleepByCycleID = `-- name: GetSleepByCycleID :one
SELECT id, cycle_id, v1_id, user_id, created_at, updated_at, start, "end", timezone_offset, nap, score_state, score_json, fetched_at FROM sleeps WHERE cycle_id = ? AND nap = 0 LIMIT 1
`

func (q *Queries) GetSleepByCycleID(ctx context.Context, cycleID int64) (Sleep, error) {
	row := q.db.QueryRowContext(ctx, getSleepByCycleID, cycleID)
	var i Sleep
	err := row.Scan(
		&i.ID,
		&i.CycleID,
		&i.V1ID,
		&i.UserID,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.Start,
		&i.End,
		&i.TimezoneOffset,
		&i.Nap,
		&i.ScoreState,
		&i.ScoreJson,
		&i.FetchedAt,
	)
	return i, err
}

const getSleepsByDateRange = `-- name: GetSleepsByDateRange :many
SELECT id, cycle_id, v1_id, user_id, created_at, updated_at, start, "end", timezone_offset, nap, score_state, score_json, fetched_at FROM sleeps
WHERE start >= ?1 AND start <= ?2
ORDER BY start DESC
LIMIT ?3
`

type GetSleepsByDateRangeParams struct {
	RangeStart time.Time `json:"range_start"`
	RangeEnd   time.Time `json:"range_end"`
	Limit      int64     `json:"limit"`
}

func (q *Queries) GetSleepsByDateRange(ctx context.Context, arg GetSleepsByDateRangeParams) ([]Sleep, error) {
	rows, err := q.db.QueryContext(ctx, getSleepsByDateRange, arg.RangeStart, arg.RangeEnd, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Sleep{}
	for rows.Next() {
		var i Sleep
		if err := rows.Scan(
			&i.ID,
			&i.CycleID,
			&i.V1ID,
			&i.UserID,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.Start,
			&i.End,
			&i.TimezoneOffset,
			&i.Nap,
			&i.ScoreState,
			&i.ScoreJson,
			&i.FetchedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getSleepsByDateRangeCursor = `-- name: GetSleepsByDateRangeCursor :many
SELECT id, cycle_id, v1_id, user_id, created_at, updated_at, start, "end", timezone_offset, nap, score_state, score_json, fetched_at FROM sleeps
WHERE start >= ?1 AND start <= ?2 AND start < ?3
ORDER BY start DESC
LIMIT ?4
`

type GetSleepsByDateRangeCursorParams struct {
	RangeStart time.Time `json:"range_start"`
	RangeEnd   time.Time `json:"range_end"`
	Cursor     time.Time `json:"cursor"`
	Limit      int64     `json:"limit"`
}

func (q *Queries) GetSleepsByDateRangeCursor(ctx context.Context, arg GetSleepsByDateRangeCursorParams) ([]Sleep, error) {
	rows, err := q.db.QueryContext(ctx, getSleepsByDateRangeCursor,
		arg.RangeStart,
		arg.RangeEnd,
		arg.Cursor,
		arg.Limit,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Sleep{}
	for rows.Next() {
		var i Sleep
		if err := rows.Scan(
			&i.ID,
			&i.CycleID,
			&i.V1ID,
			&i.UserID,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.Start,
			&i.End,
			&i.TimezoneOffset,
			&i.Nap,
			&i.ScoreState,
			&i.ScoreJson,
			&i.FetchedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const upsertSleep = `-- name: UpsertSleep :exec
INSERT INTO sleeps (id, cycle_id, v1_id, user_id, created_at, updated_at, start, end, timezone_offset, nap, score_state, score_json, fetched_at)
VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, CURRENT_TIMESTAMP)
ON CONFLICT(id) DO UPDATE SET
    cycle_id = excluded.cycle_id,
    v1_id = excluded.v1_id,
    user_id = excluded.user_id,
    created_at = excluded.created_at,
    updated_at = excluded.updated_at,
    start = excluded.start,
    end = excluded.end,
    timezone_offset = excluded.timezone_offset,
    nap = excluded.nap,
    score_state = excluded.score_state,
    score_json = excluded.score_json,
    fetched_at = CURRENT_TIMESTAMP
`

type UpsertSleepParams struct {
	ID             string    `json:"id"`
	CycleID        int64     `json:"cycle_id"`
	V1ID           *int64    `json:"v1_id"`
	UserID         int64     `json:"user_id"`
	CreatedAt      time.Time `json:"created_at"`
	UpdatedAt      time.Time `json:"updated_at"`
	Start          time.Time `json:"start"`
	End            time.Time `json:"end"`
	TimezoneOffset string    `json:"timezone_offset"`
	Nap            int64     `json:"nap"`
	ScoreState     string    `json:"score_state"`
	ScoreJson      *string   `json:"score_json"`
}

func (q *Queries) UpsertSleep(ctx context.Context, arg UpsertSleepParams) error {
	_, err := q.db.ExecContext(ctx, upsertSleep,
		arg.ID,
		arg.CycleID,
		arg.V1ID,
		arg.UserID,
		arg.CreatedAt,
		arg.UpdatedAt,
		arg.Start,
		arg.End,
		arg.TimezoneOffset,
		arg.Nap,
		arg.ScoreState,
		arg.ScoreJson,
	)
	return err
}
